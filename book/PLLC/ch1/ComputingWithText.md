### 定义集合

#### 一个BNF
B = t
  | f
  | (B•B)

集合B是由递归定义的，所以B中的元素是无限的

#### 关系 relation
一个relation 表示一个集合，其中元素都由(对:pair)组成
例子:
1. 反射关系: 可以代表用集合 B 中元素匹配它自己; a ∈ B => ⟨a, a⟩ ∈ ≡; 也可以表示为 a ≡ a
2. 对称关系: a R b => b R a
3. 传递关系: a R b and b R c => a R c

如果一个 relation 是: 反射的 and 对称的 and 传递的，那么这个关系是 等价关系(equivalence)
例子:
(f • B1) ≈ B1
(t • B1) ≈ t
B1 ≈ B1

B1 ≈ B2 => B2 ≈ B1
B1 ≈ B2 and B2 ≈r B3 => B1 ≈ B3

#### relation 当做 求值
上述例子是一个 ture false 和 • 代表 or 操作， ≈ 代表等价
可推出:
(f • t) ≈ (t • t)

#### 直接求值
`r` 单次规约
`~` 多次规约

#### 在上下文中求值
((f • t) • f) 无法直接规约，这种形式在定义中是没有约束的
只有 (f • B) 是被定义约束的，可规约的，但此时 B 是任意值
将 r 扩展成 `->` 用以表示 子表达式的规约

B1 r B2 => B1 -> B2
将 B1 子表达式规约为 B1'
B1 -> B1' => (B1 • B2) -> (B1' • B2)
将 B2 子表达式规约为 B2'
B2 -> B2' => (B1 • B2) -> (B1 • B2')

那么
(f • t) r t
=> (f • t) -> t

((f • t) • f) -> (t • f) -> t

`->` 代表单次规约子表达式，如果定义 `->>` 是 `->` 的 反射-传递扩展
那么 `->>` 就代表的是多次规约子表达式

#### 求值 Function
`eval` relation
eval(B) = f  if B = f
        = t  if B = t
现在用了另一种形式表示relation，这种方式暗示着它是一个Funtion，
这种关系表示遍历每个元素，映射到另一个元素
我们用Function这种表示是因为: 如果 `eval` 作为一个可被理解的求值器，必须是一个函数


